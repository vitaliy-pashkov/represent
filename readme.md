Yii2-Represent
====

Yii2 расширение для работы со структурами данных в реляционных БД.

Задачи, решаемые расширением:

  - Декларативный стиль описания структуры данных
  - Полноценный CRUD для структур данных
  - Limit, offset, count работающие так как хочется
  - REST API

##Установка


##Использование

Перед использованием, необходимо сгенерировать модели таблиц ActiveRecord

### 1. Вместо ActiveRecord

```php
$userRepresent = new Represent([            //объявление структуры
    '#model' => User::class,
    '#actions' => 'crud',
    '#limit' => 10,
    '*',
    'orders' => [
        'status',
    ]
]);
$users = $userRepresent->getAll();          //выборка структуры
$users[0]['orders'][0]['status'] = 'new';   //изменение структуры
$userRepresent->saveAll($users);            //сохранение структуры
```

### 2. Наследование классов от Represent

* Создаём класс в пространстве имён `app\represents\MODEL_NAME` или `app\modules\MODULE_NAME\represents\MODEL_NAME`
* Описываем структуру методом `getMap`
```php
namespace app\represent\user;
class Edit extends Represent
    {
    public function getMap()
        {
        return [
            '#model' => User::class,
            '#actions' => 'crud',
            '#limit' => 10,
            '*',
            'orders' => [
                'status',
            ]
        ];
        }
    }
```
#### 2.1 Создаём объект класса по имени и используем CRUD методы 
```php
$userRepresent = Represent::create('user/edit');
$users = $userRepresent->getAll();          //выборка структуры
$users[0]['orders'][0]['status'] = 'new';   //изменение структуры
$userRepresent->saveAll($users);            //сохранение структуры
```
#### 2.2 Создаём api контроллер унаследованный от RepresentController, реализующий REST API

Обращаемся к CRUD действиям контроллера:  
GET /api/all?represent=user/edit  
GET /api/one?represent=user/edit  
POST /api/save?represent=user/edit  
POST /api/delete?represent=user/edit  

## Represent API


| Scope | Method | Description |
| --------| -------- | -------- |
| public | __construct(`$map = false`, `$options=[]`) | Конструктор |
| public | setMap(`$map`) | Переопределяет структуру данных |
| public | getAll() | Возвращает массив структур данных |
| public | getOne() | Возвращает структуру данных |
| public | getCount() | Возвращает количество структур данных с учётом `#where` зависимых записей и `#offset` |
| public | getMeta() | Возвращает статистику по структуре |
| public | getDicts() | Возвращает словари |
| public | getDict($dictName) | Возвращает словарь по имени |
| public | saveAll(`$rows`) | Возвращает массив статусов сохранения и новые структуры |
| public | saveOne(`$row`) | Возвращает статус сохранения и новую структуру |
| public | deleteAll(`$rows`) |Возвращает массив статусов удаления и структуры, содержащие только первичный ключ удалённых записей|
| public | deleteOne(`$row`) | Возвращает статус удаления и структуру, содержащую только первичный ключ удалённой записи |
| protected | getMap() | Переопределение метода позволяет описать структуру данных в унаследованном классе. Возвращает `$map` |
| protected | getDictMaps() | Переопределение метода позволяет описать структуры словарей. Возвращает hash массив ```['dictName' => $dictMap]``` |
| protected|  getDefaultOptions() | Переопределение метода позволяет описать параметры по умолчанию. Возвращает массив параметров |
| protected | process(`$rows`) | Переопределение метода позволяет обработать данные после выборки. Возвращает `$rows`|
| protected | deprocess(`$row`) | Переопределение метода позволяет обработать данные перед сохранением или удалением. Возвращает `$row`|
| protected | processDICT_NAME($dict) | Определение метода позволяет обработать данные словаря после выборки |

| Scope | Property | Description |
| --------| -------- | -------- |
| public | $maxLimit = 1000000 | Int, Максимальный limit для запросов. Используется для предотвращения DoS-атак  |
| public | $options | Array, Свойства собираются из `getDefaultOptions()`, GET и POST параметров запроса и аргумента $options в конструкторе. Следует использовать для описания $map в общем виде |
| protected | $collectRequestOptions = true | Boolean, Если свойство определено в true, Represent собирает GET и POST параметры запроса в свойство $options |


### Описание структуры данных $map

Структура данных описывается ассоциативным массивом PHP.  
Ключ специальных полей начинается с символа `#`   
Поля таблицы указываются без ключа.   
Связанные таблицы указываются ключом - названием связи ActiveRecord.   
Нет необходимости указывать первичные и внешние ключи - они добавятся автоматически.

Структура данных сохраняется в объекте Represent и используется для CRUD методов.
Переопределить структуру данных можно методом `setMap($newMap)`
  

#### Рекомендуемый алгоритм описания структуры:
* Указываем корневую модель запроса `#model`
* Указываем действия `#actions`, которые Represent может делать с данной таблицей
* Перечисляем правила выборки `#where`, `#order`, `#limit`, `#offset`
* Перечисляем поля, которые нужно выбрать из таблицы
* Перечисляем свзи модели с другими моделями
  - действия `#actions`, которые Represent может делать с данной таблицей
  - правила выборки `#where`
  - поля, которые нужно выбрать
  - повторяем рекурсивно для всех связанных моделей
   
#### Полный пример:
```php
new Represent([
    // Специальные поля
    '#model' => Table1::class,
    '#actions' => 'crud',
    '#whereId' => 'id = 1',
    '#where1' => ['table2s.field1' => 'some_value'],
    '#order' => 'table2.field1',
    '#limit' => 10,
    '#offset' => 10,
    //Поля таблицы table1
    'field1',
    'field2',
    'field3',
    //Связанная таблица table2. Ключ 'table2s' - название связи ActiveRecord
    'table2s' => [
        // Специальные поля
        '#actions' => 'crud',
        // Поля таблицы table2
        'field1',
        'field2',
        //Связанная таблица table3.
        'table3' => [
            '#actions' => 'crud',
            '*', // Выбрать все поля таблицы
        ],
    ],
    //Связанная таблица table4.
    'table4' => [
        //Если не указывать никакие поля таблицы выберется только первичный ключ
    ]
]);
```

#### Специальные поля в описании структуры

##### * 
Указывается без ключа. Выбирает все поля текущей таблицы.

##### #model
Класс корневой модели.   
Обязательное поле у корневой модели. В дочерних структурах игнорируется.
##### #actions
Строка которая может содержать символы 'crud'. Наличие символа в строке разрешает соответствующее действие с данной моделью. Для каждой структуры (корневой и дочерних) разная.  
Не обязательное поле. По умолчанию: `'r'`
##### #where...
Ключ массива, начинающийся с '#where' описывает условие выборки. Можно описать несколько условий таким образом:
```
'#whereId' => ['id' => 1],
'#whereStatusNew'  => 'status = "new"'
```
Условия объединяются оператором 'AND'  
Значением может быть SQL строка или массив в hash формате yii (формат операторов пока не поддерживается)  
Условия, указанные у дочерних моделей добавляются к условию JOIN ON    
Не обязательное поле.
##### #order
Поля по которым сортируется выборка. SQL Строка или массив в hash формате.  
Указывается только у корневой модели.  
Не обязательное поле.

##### #limit 
Количество записей корневой модели, которые необходимо выбрать. Связанные модели не влияют на количество записей.  
Указывается только у корневой модели.  
Не обязательное поле.

##### #offset 
Количество первых записей корневой модели, которые пропускаются при выборке. Связанные модели не влияют на offset.  
Указывается только у корневой модели.  
Не обязательное поле.  

##### Обращение к полям таблиц в значениях специальных полей #where и #order
Вне зависимости от позиции специального поля можно обратиться к любому полю дочерней таблицы с указанием полного пути до этого поля.  
Поля коренной таблицы указываются без префикса: `id`, `field1`  
Поля дочерних таблиц: `table2s.field1`, `table2s.table3.field1`  
Таким образом, конфликт имён не возможен.  
В строках имена полей должны быть отделены пробелами, в том числе от скобок.  


### Параметризация структуры данных

#### `$options`
При наследовании от Represent и описании структуры данных методом `getMap()` структуру данных необходимо описывать в общем виде.  

Пример:
```php
namespace app\represent\user;
class View extends Represent
    {
    public function getDefaultOptions()
        {
        return [
            'id' => null,
        ];
        }
    
    public function getMap()
        {
        return [
            '#model' => User::class,
            '#where' => ['id' => $this->options['id']]
            '*'
        ];
        }
    }
```

`$this->options['id']` пользователя может быть получен из GET или POST параметров запроса или из конструктора класса.

#### `$options['map']`

Некоторые параметры запроса могут быть переданы в `$map` автоматически из `$options['map']`   
`$options['map']` - json строка со следующей структурой:
 
```json
{
  "filter": [FilterData], //Структура данных фильтра 
  "where": [WhereType], //Аналогично #where
  "order":  [OrderType], //Аналогично #order
  "limit": [int], 
  "offset":  [int]
}
```
Все поля опциональны.

### Выборка данных

Данные выбираются методами `getAll()` и `getOne()`  
* Реализуется жадная загрузка;  
* Методами ActiveQuery формируется один SQL запрос;  
* Связанные таблицы выбираются с помощью LEFT JOIN;  
* \#where связанных таблиц добавляется к условию ON;  
* \#limit реализуется с помощью подзапроса во FROM, работает именно так, как он и должен работать (однако, применим только к корневой таблице);  
* После выполнения запроса строятся структуры данных алгоритмом сложностью N в лучшем случае и N*M/2 в худшем случае (где N - кол-во строк в выборке, M - итоговое кол-во структур данных ).
* После построения структуры данных вызывается метод `process($rows)` который можно переопределить, что позволяет дополнительно обработать данные
* Жизненный цикл получения данных ActiveRecord НЕ СОХРАНЯЕТСЯ
* Для соединения с БД используется метод getDb() корневой модели

### Сохранение данных

Данные сохраняются методами `saveAll($rows)` и `saveOne($row)`
* Сохранение осуществляется методами ActiveRecord, поэтому сохраняется [жизненный цикл сохранения данных ActiveRecord](http://stuff.cebe.cc/yii2docs-ru/guide-db-active-record.html#saving-data-life-cycle)
* Автоматически определяется порядок в котором необходимо сохранять модели, чтобы избежать конфликта внешних ключей
* Сохраняются только поля таблиц, перечисленные в `$map` (в том числе специальным полем `*`)
* Модель создаётся только если в `#actions` текущей модели есть флаг create - `c`, иначе действие игнорируется
* Модель изменяется только если в `#actions` текущей модели есть флаг update - `u`, иначе действие игнорируется
* Флаги в данных:
    * **`'#delete' => true`** добавление данного флага в сохраняемую структуру данных удалит текущую и дочерние модели, если в `#actions` моделей есть флаг delete - `d`
    * **`'#unlink' => true`** добавление данного флага вызывает метод `unlink()` у связанных моделей

### Удаление данных

Данные удаляются методами `deleteAll($rows)` и `deleteOne($row)`
* Удаление осуществляется методами ActiveRecord, поэтому сохраняется [жизненный цикл удаления данных ActiveRecord](http://stuff.cebe.cc/yii2docs-ru/guide-db-active-record.html#deleting-data-life-cycle) 
* Автоматически определяется порядок в котором необходимо удалять модели, чтобы избежать конфликта внешних ключей
* Модель удаляется только если в `#actions` есть флаг update `d`, иначе действие игнорируется

### Словари

При работе со структурами данных, зачастую, возникает необходимость обращаться к данным, которые напрямую не входят в структуру, но тем или иным образом аффилированы с ней.  
Например, чтобы сформировать select связанной модели - необходим перечень всех моделей.  
  
Словари - структуры данных, описываемые в методе `getDictMaps()`, которые можно выбирать методами `getDicts()` и `getDict($dictName)`.  
Структуры данных описываются аналогичным образом, за некоторым исключением:
* Поле `#action` - игнорируется; словари можно только выбирать
* Поле `#singleton` boolean; если true, словарь не выбирается методом `getDicts()`; имеет смысл при параметризации структуры словаря  

После выборки словаря вызывается метод `processDICT_NAME($rows)` (где DICT_NAME = ucfirst(имя словаря)) если он определён. 


## RepresentController API

RepresentController реализует REST API для методов Represent.  
Для использования необходимо создать контроллер унаследованный от RepresentController.


| Scope | Method | Description |
| --------| -------- | -------- |
| public | actionOne($represent, $dicts = false) | Возвращает json Represent->getOne(); если $dicts == true добавляет к результату Represent->getDicts() |
| public | actionAll($represent,  $count = false, $meta = false, $dicts = false) | Возвращает json Represent->getAll(); опционально добавляет getCount(), getDicts(), getMeta() |
| public | actionSave($represent) | В POST параметрах ищет `rows` или `row` и вызывает Represent->saveAll($rows) или $represent->saveOne($row) соответственно. Возвращает json статусов сохранения|
| public | actionDelete($represent) | В POST параметрах ищет `rows` или `row` и вызывает Represent->deleteAll($rows) или $represent->deleteOne($row) соответственно. Возвращает json статусов удаления|
| public | actionDicts($represent) | Возвращает json Represent->getDicts() |
| public | actionDict($represent, $dictName) | Возвращает json Represent->getDict($dictName) |
| public | actionCount($represent) | Возвращает json Represent->getCount() |
| public | actionMeta($represent) | Возвращает json Represent->getMeta() |

Параметр $represent для действий - имя Represent, формируемое следующим образом.  
Двусложное имя:  
`'user/view-all'` - создаст экземпляр класса `\app\represents\user\ViewAll`  

Трёхсложное имя:  
`'admin/user/viewAll'` - создаст экземпляр класса `\app\modules\admin\represents\user\ViewAll`
